# 12.12

124\. 二叉树中的最大路径和
----------------

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

**输入：**root = \[1,2,3\]
**输出：**6
**解释：**最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

**输入：**root = \[-10,9,20,null,null,15,7\]
**输出：**42
**解释：**最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42

**提示：**

*   树中节点数目范围是 `[1, 3 * 104]`
*   `-1000 <= Node.val <= 1000`

[https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func maxPathSum(root *TreeNode) int {
	ans := -100000000
	var dfs func(*TreeNode) int
	dfs = func(node *TreeNode) int{
		if node == nil {
			return 0
		}
		l := dfs(node.Left)
		r := dfs(node.Right)

		ans = max(ans, l+r+node.Val)
		return max(max(l,r) + node.Val,0)
	}
    	dfs(root)
	return ans
}
```

思路：，从根节点出发，遍历获取左右子树的最大路径和，同时ans更新为，左+右+中和原来ans的最大值，返回值为左/右+中的最大值，如果小于小于0，则返回0表示不选这条路。

![image-20241212222001958](https://gitee.com/liu-bingduo/pic-bed/raw/master/image-20241212222001958.png)