# 12月11日

1522\. N 叉树的直径
--------------

给定一棵 `N 叉树` 的根节点 `root` ，计算这棵树的直径长度。

N 叉树的直径指的是树中任意两个节点间路径中 **最长** 路径的长度。这条路径可能经过根节点，也可能不经过根节点。

_（N 叉树的输入序列以层序遍历的形式给出，每组子节点用 null 分隔）_

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/07/19/sample_2_1897.png)

**输入：**root = \[1,null,3,2,4,null,5,6\]
**输出：**3
**解释：**直径如图中红线所示。

**示例 2：**

**![](https://assets.leetcode.com/uploads/2020/07/19/sample_1_1897.png)**

**输入：**root = \[1,null,2,null,3,4,null,5,null,6\]
**输出：**4

**示例 3：**

![](https://assets.leetcode.com/uploads/2020/07/19/sample_3_1897.png)

**输入:** root = \[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14\]
**输出:** 7

**提示：**

*   N 叉树的深度小于或等于 `1000` 。
*   节点的总个数在 `[0, 10^4]` 间。

[https://leetcode.cn/problems/diameter-of-n-ary-tree/description/](https://leetcode.cn/problems/diameter-of-n-ary-tree/description/)

```go
/**
 * Definition for a Node.
 * type Node struct {
 *     Val int
 *     Children []*Node
 * }
 */

func diameter(root *Node) int {
	ans:=0
	if root == nil{
		return 0
	}
	var dfs func(root *Node) int
	dfs = func(root *Node) int {
		m1,m2,c_len := 0,0,0
		for _, child := range root.Children {
			c_len = dfs(child) + 1
			if c_len > m1 {
				m2 = m1
				m1 = c_len
			} else if c_len > m2 {
				m2 = c_len
			}
		}
		ans = max(ans,m1+m2)
		return m1
	}
    dfs(root)
    return ans
}
```

![image-20241212222116635](https://gitee.com/liu-bingduo/pic-bed/raw/master/image-20241212222116635.png)